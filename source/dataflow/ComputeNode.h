//
// Created by david on 20/12/2019.
//

#ifndef GRAPHKAT_COMPUTENODE_H
#define GRAPHKAT_COMPUTENODE_H

#include <vector>
#include "nodeprims/macro_shenanigans.h"

using std::vector;

class Context;

typedef void (*ComputeFunc_t)(Context *, Context *);

/*
 * Dynamic typing system based on Endpoints
 *
 * The idea is that where possible functions should be written only once instead of copy pasting for each time
 * Take addition over ints, floats, vectors etc. for example:
 * - two inputs: a and b
 * - one output: res
 * - code body: res = a + b
 *
 * To achieve this a Math class will be created:
 *
 * in Math.h:
 *     ComputeFuncT(Addition, a);
 *                   ^        ^
 *   name of the function     the Endpoint name from which the type will be deduced
 *
 * in Math.cpp:
 *     LINK_TEMPLATE(Math, Addition, int, float, vec2)
 *                    ^      ^       ^______^______^
 *                    |      |     all possible types of T
 *            class name   function name
 *
 *     template<typename T> // this header should get auto generated by IDE
 *     void Math::_Addition(Context *in_ctx, Context *out_ctx) {
 *
 *         // EndpointInputValue get the value of the "a" Endpoint from in_ctx as T type
 *         T a = EIV(a, T);
 *
 *         // EndpointOutputValue set the value of the "res" Endpoint from out_ctx as T type
 *         EOV(res, T, a + EIV(b, T)); // EIV can be used directly too,
 *     }
 */
#define ComputeFunc(name) public: static void name(Context *in_ctx, Context *out_ctx)
#define MAP_ENTRY(name, type) {typeid(type), CAT(_,name)<type>}
#define MAP_ENTRIES(name, ...) ApplyMacro(MAP_ENTRY, name, __VA_ARGS__)
#define ComputeFuncT(name, type_endpoint) private:\
template<typename T> static void CAT(_, name)(Context *in_ctx, Context *out_ctx);\
static std::unordered_map<std::type_index, ComputeFunc_t> DCAT(_,name,_dynamic_map);\
public:\
static void name(Context *in_ctx, Context *out_ctx) { DCAT(_,name,_dynamic_map)[in_ctx->endpoint(#type_endpoint)->type()](in_ctx, out_ctx); }
#define LINK_TEMPLATE(namespace, name, ...) std::unordered_map<std::type_index, ComputeFunc_t> namespace::DCAT(_,name,_dynamic_map) = {MAP_ENTRIES(name, __VA_ARGS__)};


class ComputeNode {
private:
    void (*func)(Context *in_ctx, Context *out_ctx);

public:
    Context *inputs = nullptr;
    Context *outputs = nullptr;


    ComputeNode();

    void execute();
};


#endif //GRAPHKAT_COMPUTENODE_H
